## Traverse?
배열과 링크드리스트에서는 sequential하게 순회하는 방법이 존재한다.
그럼 Tree에서는? 어떻게 탐색해야 하지?
방법을 찾는데 가능하다면 시간, 공간 복잡도 측면에서 O(n)으로!
=> BFS, DFS

## BFS
queue 이용.
같은 level에 있는 노드를 전부큐에 저장해야 한다. 만약 가로로 엄청 넓다면 memory intensive할 수 있다.
**즉 공간 복잡도는 주어진 depth에 있는 노드의 최대 갯수에 영향을 받는다.**
![](https://i.imgur.com/KGlle4S.png)

## DFS
backtracking.
**At some point, we have to go back!**
남아있는 children이 없으면 parent로 backtrack.

주목할 점은 BFS에서는 한 노드를 한 번만 탐색하지만 DFS에서는 백트래킹 때문에 한 노드를 여러 번 방문할 수도 있다. 
recursion으로 구현하면 쉽다. 

`print_dfs_tree` 는 DFS의 탐색 순서를 출력하는 함수임.

recursive function이 내부적으로 stack을 이용하는데, 그렇다면 DFS를 stack을 이용하여 구현할 수도 있을 것이다.
![](https://i.imgur.com/bFDMiVS.png)
만약 위와 같은 순서로 구현하고 싶으면 children을 **reversed order**로 넣어줘야 한다.
즉 A의 자식을 stack에 넣을 때 H, B 순서로 넣어야 위와 같이 순회가 된다.

DFS는 BFS에서 문제가 되었던 가로로 엄청 긴 ugly tree에서 memory 이슈가 발생하지 않는다. 그냥 백트래킹으로 와다다다 조지기 때문에 메모리 측면에서 좋다. 근데 밑으로 쭉쭉 깊은 트리는...
만약 각 노드가 최대 2개의 자식을 가진다면 Memory Complexity = Big-Theta(height)이다.
Runtime Complexity는 Big-Theta(n)이다.

# Applications
## 1. height
DFS 돌리면서 max height 기록
## 2. Print a Hierarchy
같은 level(depth)에 있는 값은 같은 indentation을 준다.
DFS를 돌리면서 출력하면 된다.

DFS, BFS는 런타임 측면에서는 같은 복잡도를 갖지만 메모리 측면에서 상황에 따라 다른 공간 복잡도를 갖기 때문에 주의해야 한다.

---
## Parental Tree(Parent-Pointer Tree)

![](https://i.imgur.com/28aXWir.png)
**적은 메모리**를 쓰는 것이 최대 장점!
일반적인 Tree 구조에서는 부모/자식을 가리키는 두 개의 포인터를 가지고 있어야 하지만 여기서는 부모만 가리킨다. 
**자료구조에서는 Memory-Runtime Trade-off를 생각할 것!**

### \<Node Base Implemetation>

```c++
template <typename Type>
class Parental_tree {
	private:
		Type element;
		Parental_tree *parent;
	public:
// ...
};
```

### \<Array Base Implementation>
![](https://i.imgur.com/0W3WTES.png)
루트는 자기 자신을 가리킨다.
다른 노드들은 부모 노드의 index를 자기 자신의 값으로 저장한다.
node base 방식에 비해 memory requirement가 매우 적다. 노드 개수만큼의 메모리만 할당하면 되기 때문.
node base는 random access인데 array base는 sequential access이기 때문에 런타임 측면에서 빠르다.
반면에 array base로 구현 한 경우 Tree의 크기를 늘려야 하는 상황이 오면 큰일난다 !! 새로운 contiguous 공간을 할당해서 다 옮겨야 한다.

## Convert parental tree to a simple tree structure

간단하다. 
1. 먼저 루트를 찾아서 정의해놓고
2. 다른 노드는 전부 부모 밑으로 갖다 붙이면 된다.
```c++
int const n = 20;
int parent_array[n] = { 0, 0, 0, 0, 0, 2, 2, 2, 3, 3,
4, 4, 4, 4, 5, 5, 10, 12, 12, 15};

Simple_tree<Type> *root_node = nullptr;
Simple_tree<Type> *array = new Simple_tree<Type> *[n];

for ( int i = 0; i < n; ++i ) {
	array[i] = new Simple_tree<Type>();
}

for ( int i = 0; i < n; ++i ) {
	/* Detect root node */
	if ( parent_array[i] == i ) {
		root_node = array[i];
	} 
	else array[parent_array[i]]->attach(array[i]);
}
```

parental tree representation은 topological sorting, prim, dijkstra 알고리즘에 사용된다.